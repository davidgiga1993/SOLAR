package dhbw.karlsruhe.it.solar.core.physics;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlSeeAlso;

import dhbw.karlsruhe.it.solar.core.astronomical_objects.AstronomicalBody;
import dhbw.karlsruhe.it.solar.core.physics.Temperature.TempUnit;
import dhbw.karlsruhe.it.solar.core.resources.AtmosphericGas;

@XmlAccessorType(XmlAccessType.NONE)
@XmlSeeAlso({Temperature.class})
public class SurfaceTemperature {
    
    private static final float ROTATION_SCALAR = 1/(3*(float)Math.sqrt(2));
    private static final float INTERNAL_HEAT_SCALAR = 7.72757f * (float)Math.pow(10,-6);
    private static final float TIDAL_HEATING_SCALAR = 100;
    @XmlElement(name = "Min_Temperature")
    private Temperature tempMinimum;
    @XmlElement(name = "Mean_Temperature")
    private Temperature meanTemperature;
    @XmlElement(name = "Max_Temperature")
    private Temperature tempMaximum;
    
    public SurfaceTemperature() {
        
    }
    
    public SurfaceTemperature(Temperature tempMinimum, Temperature meanTemperature, Temperature tempMaximum) {
        this.tempMinimum = tempMinimum;
        this.meanTemperature = meanTemperature;
        this.tempMaximum = tempMaximum;
    }

    public SurfaceTemperature(Temperature temperature) {
        this.tempMinimum = null;
        this.meanTemperature = temperature;
        this.tempMaximum = null;
    }

    public Temperature getMeanTemperature() {
        return meanTemperature;
    }

    public Temperature getMinimumTemperature() {
        if(null!=tempMinimum) {
            return tempMinimum;
        }
        return meanTemperature;
    }

    public Temperature getMaximumTemperature() {
        if(null!=tempMaximum) {
            return tempMaximum;
        }
        return meanTemperature;
    }
    
    @Override
    public String toString() {
        return formatValue(getMeanTemperature()) + " K";
    }

    private String formatValue(Temperature temp) {
        return String.format("%.00f", temp.inKelvin());
    }

    public void calculateSurfaceTemperature(AstronomicalBody body) {
        meanTemperature = new Temperature( calculateThermalEquilibrium(body) + calculateAdditionalTemperatureInfluences(body), TempUnit.KELVIN);      
    }

    private float calculateAdditionalTemperatureInfluences(AstronomicalBody body) {
        return greenhouseEffect(body) + internalHeat(body.getMass()) + tidalHeating(body);
    }

    private float tidalHeating(AstronomicalBody body) {
        if(body.isRounded()) {
            return TIDAL_HEATING_SCALAR * body.getPrimary().getRadius().asKilometers() / body.getOrbitalRadius().asKilometers();
        }
        return 0;
    }

    /**
     * Calculates the internal heat generated by a gas giant according to the Kelvin-Helmholtz Mechanism.
     * Only makes a very rough approximation, doesn't use the actual formula.
     * @param bodyMass
     * @return
     */
    private float internalHeat(Mass bodyMass) {
        if(bodyMass.asEarthMass()>5f) {
            return INTERNAL_HEAT_SCALAR*(float)Math.sqrt(Math.sqrt(bodyMass.asKilogram()));            
        }
        return 0;
    }

    /**
     * Calculates (roughly) the cumulative greenhouse effect generated by the greenhouse gases in the atmosphere.
     * @param body
     * @return
     */
    private float greenhouseEffect(AstronomicalBody body) {
        if(body.hasAtmosphere()) {
            float greenhouseEffect = 0;
            for (AtmosphericGas gas : body.getListOfAtmosphericGases()) {
                greenhouseEffect += gas.greenhouseEffect(body.getPhysicalProperties());
            }
            return greenhouseEffect;            
        }
        return 0;
    }

    /**
     * Calculates the Temperature of a body according to the thermal equilibrium pricniple.
     * This assumes that the body's only source of incoming energy is its star and that it has reached an equilibrium, radiating away exactly as much energy via black body radiation as it receives.
     * Calculation therefore neglects other possible energy sources such as greenhouse gases, geothermal activtiy, or tidal forces.
     * @param body
     * @param albedo
     * @return
     */
    private float calculateThermalEquilibrium(AstronomicalBody body) {
        return body.getTemperatureOfStar().inKelvin() * (float)Math.sqrt(getRelativeTemperatureValue(body.getRadiusOfStar(), body.getAlbedo(), body.getMeanDistanceToStar())) * rotationRatioNormalizer(body);
    }

    /**
     * Slow rotation causes the planet to cool off disproportionately on its night side if it does not have a thick atmosphere.
     * While the body will also heat up on the day side where it is noon, the end result averaged as the surface temperature of the entire planet is a cooler surface.
     * Values not chosen according to actual physical formula - formula cobbled together as an assumption and then resulting values adjusted via scalar.
     * @param body
     * @return
     */
    private float rotationRatioNormalizer(AstronomicalBody body) {
        return 1 - ROTATION_SCALAR * rotationImpact(body) * atmosphericConvection(body.getSurfacePressure());
    }

    private float rotationImpact(AstronomicalBody body) {
        float daylight = lengthOfDayLight(body);
        if(daylight > 3) {
            return 1 - 1/(daylight/3);            
        }
        return 0;
    }
    
    private float lengthOfDayLight(AstronomicalBody body) {
        return body.getOrbitalPeriodAroundSun().inDays() / actualDaysPerYear(body) / 2;
    }

    private float actualDaysPerYear(AstronomicalBody body) {
        return (1 - body.solarRotationRatio()) / body.solarRotationRatio();
    }

    private float atmosphericConvection(Pressure pressure) {
        return 1/(1+pressure.asBar());
    }

    private double getRelativeTemperatureValue(Length radiusOfStar, Albedo albedo, Length orbitalDistance) {
        return radiusOfStar.asMeters() * Math.sqrt( 1 - albedo.getAlbedoValue()) / (2*orbitalDistance.asMeters());
    }
}
